diff --git a/ios/ExpoShareIntentModule.podspec b/ios/ExpoShareIntentModule.podspec
index 6db146996720008f9ce6f1809b6ec7f6951a78e9..8b63c33060bccc1b01e65b0e3aa51d931c422dab 100644
--- a/ios/ExpoShareIntentModule.podspec
+++ b/ios/ExpoShareIntentModule.podspec
@@ -10,7 +10,7 @@ Pod::Spec.new do |s|
   s.license        = package['license']
   s.author         = package['author']
   s.homepage       = package['homepage']
-  s.platform       = :ios, '13.0'
+  s.platform       = :ios, '15.0'
   s.swift_version  = '5.4'
   s.source         = { git: 'https://github.com/achorein/expo-share-intent' }
   s.static_framework = true
diff --git a/plugin/build/ios/ShareExtensionViewController.swift b/plugin/build/ios/ShareExtensionViewController.swift
index 67036867bd4a082140d2f8ae5000caea9cdb50fb..c95e4d18fe8cfe9e0be1ff0991a9cde8382428a6 100644
--- a/plugin/build/ios/ShareExtensionViewController.swift
+++ b/plugin/build/ios/ShareExtensionViewController.swift
@@ -1,496 +1,579 @@
-/*!
- * Native module created for Expo Share Intent (https://github.com/achorein/expo-share-intent)
- * author: achorein (https://github.com/achorein)
- * inspired by :
- *  - https://ajith-ab.github.io/react-native-receive-sharing-intent/docs/ios#create-share-extension
- */
-import UIKit
-import Social
 import MobileCoreServices
 import Photos
+import Security
+import Social
+import UIKit
+import UniformTypeIdentifiers
+import os.log
+
+struct AuthData {
+  let userId: String
+  let username: String
+  let authToken: String
+  let expoPushToken: String
+}
 
-class ShareViewController: SLComposeServiceViewController {
-  let hostAppBundleIdentifier = "<APPIDENTIFIER>"
-  let shareProtocol = "<SCHEME>"
-  let sharedKey = "<SCHEME>ShareKey"
-  var sharedMedia: [SharedMediaFile] = []
-  var sharedText: [String] = []
+class ShareViewController: UIViewController {
   let imageContentType = kUTTypeImage as String
   let videoContentType = kUTTypeMovie as String
   let textContentType = kUTTypeText as String
   let urlContentType = kUTTypeURL as String
-  let fileURLType = kUTTypeFileURL as String;
-  
-  override func isContentValid() -> Bool {
-    return true
-  }
-      
-  override func viewDidLoad() {
-    super.viewDidLoad();
-  }
-      
+  let fileURLType = kUTTypeFileURL as String
+
   override func viewDidAppear(_ animated: Bool) {
     super.viewDidAppear(animated)
+
+    // Dismiss the share sheet immediately
+    self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
+
+    self.performShare()
+  }
+
+  func performShare() {
+    NSLog("soonlist.share-extension.shareviewcontroller: Attempting to perform share")
+    guard let authData = loadAuthData() else {
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: Failed to load auth data in performShare()")
+      return
+    }
+
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Successfully loaded auth data: userId=\(authData.userId), username=\(authData.username)"
+    )
+
+    logExtensionContext()
+
     if let content = extensionContext!.inputItems[0] as? NSExtensionItem {
       if let contents = content.attachments {
         for (index, attachment) in (contents).enumerated() {
           if attachment.hasItemConformingToTypeIdentifier(imageContentType) {
-            handleImages(content: content, attachment: attachment, index: index)
+            handleImages(content: content, attachment: attachment, index: index, authData: authData)
           } else if attachment.hasItemConformingToTypeIdentifier(textContentType) {
-            handleText(content: content, attachment: attachment, index: index)
+            handleText(content: content, attachment: attachment, index: index, authData: authData)
           } else if attachment.hasItemConformingToTypeIdentifier(fileURLType) {
-            handleFiles(content: content, attachment: attachment, index: index)
+            handleUnsupportedType(type: "fileURL")
           } else if attachment.hasItemConformingToTypeIdentifier(urlContentType) {
-            handleUrl(content: content, attachment: attachment, index: index)
+            handleUnsupportedType(type: "url")
           } else if attachment.hasItemConformingToTypeIdentifier(videoContentType) {
-            handleVideos(content: content, attachment: attachment, index: index)
+            handleUnsupportedType(type: "video")
+          } else {
+            handleUnsupportedType(type: "unknown")
           }
         }
       }
     }
   }
-  
-  private func handleText (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: textContentType, options: nil) { [weak self] data, error in
-      
-      if error == nil, let item = data as? String, let this = self {
-        this.sharedText.append(item)
-          
-        // If this is the last item, save sharedText in userDefaults and redirect to host app
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.sharedText, forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .text)
+
+  private func logExtensionContext() {
+    if let context = self.extensionContext {
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: Extension context - input items count: \(context.inputItems.count)"
+      )
+      for (index, item) in context.inputItems.enumerated() {
+        if let extensionItem = item as? NSExtensionItem {
+          NSLog(
+            "soonlist.share-extension.shareviewcontroller: Input item \(index) - attachments count: \(extensionItem.attachments?.count ?? 0)"
+          )
+          NSLog(
+            "soonlist.share-extension.shareviewcontroller: Input item \(index) - attributed content text: \(extensionItem.attributedContentText?.string ?? "nil")"
+          )
         }
-              
-      } else {
-        self?.dismissWithError(message: "Cannot load text content")
       }
+    } else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Extension context is nil")
     }
   }
-              
-  private func handleUrl (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: urlContentType, options: nil) { [weak self] data, error in
-
-      if error == nil, let item = data as? URL, let this = self {
-        this.sharedText.append(item.absoluteString)
-        
-        // If this is the last item, save sharedText in userDefaults and redirect to host app
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.sharedText, forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .weburl)
+
+  // handleImages function here
+  private func handleImages(
+    content: NSExtensionItem, attachment: NSItemProvider, index: Int, authData: AuthData
+  ) {
+    NSLog("soonlist.share-extension.shareviewcontroller: Performing automatic share with image")
+    attachment.loadItem(forTypeIdentifier: imageContentType, options: nil) {
+      [weak self] (imageData, error) in
+      guard let self = self else { return }
+      if let imageUrl = imageData as? URL {
+        let event = PrototypeEventCreateImageSchema(
+          json: PrototypeEventCreateImageSchema.EventData(
+            imageUrl: imageUrl.absoluteString,
+            timezone: TimeZone.current.identifier,
+            expoPushToken: authData.expoPushToken,
+            lists: [],
+            userId: authData.userId,
+            username: authData.username
+          )
+        )
+
+        callAiEventFromImageThenCreateThenNotification(event: event) { result in
+          switch result {
+          case .success(let data):
+            NSLog(
+              "soonlist.share-extension.shareviewcontroller: Success: \(String(data: data, encoding: .utf8) ?? "")"
+            )
+          case .failure(let error):
+            NSLog("soonlist.share-extension.shareviewcontroller: Error: \(error)")
+          }
+
+          self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
         }
       } else {
-        self?.dismissWithError(message: "Cannot load url content")
+        NSLog("soonlist.share-extension.shareviewcontroller: Failed to load image data")
+        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
       }
-
     }
   }
-  
-  private func handleImages (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: imageContentType, options: nil) { [weak self] data, error in
-
-      if error == nil, let this = self {
-        var url: URL? = nil
-        if let dataURL = data as? URL { url = dataURL }
-        else if let imageData = data as? UIImage { url = this.saveScreenshot(imageData) }
-
-        var pixelWidth: Int? = nil
-        var pixelHeight: Int? = nil
-        if let imageSource = CGImageSourceCreateWithURL(url! as CFURL, nil) {
-            if let imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as Dictionary? {
-              pixelWidth = imageProperties[kCGImagePropertyPixelWidth] as? Int
-              pixelHeight = imageProperties[kCGImagePropertyPixelHeight] as? Int
-            }
-        }
 
-        // Always copy
-        let fileName = this.getFileName(from :url!, type: .image)
-        let fileExtension = this.getExtension(from: url!, type: .image)
-        let fileSize = this.getFileSize(from: url!)
-        let mimeType = url!.mimeType(ext: fileExtension)
-        let newName = "\(UUID().uuidString).\(fileExtension)"
-        let newPath = FileManager.default
-          .containerURL(forSecurityApplicationGroupIdentifier: "group.\(this.hostAppBundleIdentifier)")!
-          .appendingPathComponent(newName)
-        let copied = this.copyFile(at: url!, to: newPath)
-        if(copied) {
-          this.sharedMedia.append(SharedMediaFile(path: newPath.absoluteString, thumbnail: nil, fileName: fileName, fileSize: fileSize, width: pixelWidth, height: pixelHeight,  duration: nil, mimeType: mimeType, type: .image))
-        }
-  
-        // If this is the last item, save imagesData in userDefaults and redirect to host app
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.toData(data: this.sharedMedia), forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .media)
+  private func handleText(
+    content: NSExtensionItem, attachment: NSItemProvider, index: Int, authData: AuthData
+  ) {
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Performing automatic share with raw text")
+    attachment.loadItem(forTypeIdentifier: textContentType, options: nil) {
+      [weak self] (textData, error) in
+      guard let self = self else { return }
+      let rawText =
+        (textData as? String) ?? content.attributedContentText?.string ?? "Event details"
+      let event = PrototypeEventCreateRawTextSchema(
+        json: PrototypeEventCreateRawTextSchema.EventData(
+          rawText: rawText,
+          timezone: TimeZone.current.identifier,
+          expoPushToken: authData.expoPushToken,
+          lists: [],
+          userId: authData.userId,
+          username: authData.username
+        )
+      )
+
+      callAiEventFromRawTextThenCreateThenNotification(event: event) { result in
+        switch result {
+        case .success(let data):
+          NSLog(
+            "soonlist.share-extension.shareviewcontroller: Success: \(String(data: data, encoding: .utf8) ?? "")"
+          )
+        case .failure(let error):
+          NSLog("soonlist.share-extension.shareviewcontroller: Error: \(error)")
         }
-        
-      } else {
-        self?.dismissWithError(message: "Cannot load image content")
+
+        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
       }
     }
   }
-  
-  private func documentDirectoryPath () -> URL?  {
-    let path = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
-    return path.first
+
+  private func handleUnsupportedType(type: String) {
+    NSLog("soonlist.share-extension.shareviewcontroller: Unsupported share type: \(type)")
+  }
+}
+
+// Define the method to call the API
+func callAiEventFromRawTextThenCreateThenNotification(
+  event: PrototypeEventCreateRawTextSchema, completion: @escaping (Result<Data, Error>) -> Void
+) {
+  // fetch the domain URL from the keychain
+  guard let domainURL = KeychainHelper.getValue(forKey: "EXPO_PUBLIC_API_BASE_URL") else {
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Failed to load EXPO_PUBLIC_API_BASE_URL from Keychain"
+    )
+    return
+  }
+
+  guard
+    let url = URL(
+      string:
+        "\(domainURL)/api/trpc/ai.eventFromRawTextThenCreateThenNotification"
+    )
+  else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Invalid URL")
+    return
   }
 
-  private func saveScreenshot(_ image: UIImage) -> URL? {
-    var screenshotURL: URL? = nil
-    if let screenshotData = image.pngData(), let screenshotPath = documentDirectoryPath()?.appendingPathComponent("screenshot.png") {
-      try? screenshotData.write(to: screenshotPath)
-      screenshotURL = screenshotPath
+  let jsonData: Data
+  do {
+    jsonData = try JSONEncoder().encode(event)
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: JSON Payload: \(String(data: jsonData, encoding: .utf8) ?? "")"
+    )
+  } catch {
+    NSLog("soonlist.share-extension.shareviewcontroller: Error encoding JSON: \(error)")
+    return
+  }
+
+  var request = URLRequest(url: url)
+  request.httpMethod = "POST"
+  request.setValue("application/json", forHTTPHeaderField: "Content-Type")
+  request.httpBody = jsonData
+
+  let task = URLSession.shared.dataTask(with: request) { data, response, error in
+    if let error = error {
+      completion(.failure(error))
+      return
     }
-    return screenshotURL
-  }
-
-  private func handleVideos (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: videoContentType, options:nil) { [weak self] data, error in
-      
-      if error == nil, let url = data as? URL, let this = self {
-        
-        // Always copy
-        let fileName = this.getFileName(from :url, type: .video)
-        let fileExtension = this.getExtension(from: url, type: .video)
-        let fileSize = this.getFileSize(from: url)
-        let mimeType = url.mimeType(ext: fileExtension)
-        let newName = "\(UUID().uuidString).\(fileExtension)"
-        let newPath = FileManager.default
-          .containerURL(forSecurityApplicationGroupIdentifier: "group.\(this.hostAppBundleIdentifier)")!
-          .appendingPathComponent(newName)
-        let copied = this.copyFile(at: url, to: newPath)
-        if(copied) {
-          guard let sharedFile = this.getSharedMediaFile(forVideo: newPath, fileName: fileName, fileSize: fileSize, mimeType: mimeType) else {
-            return
-          }
-          this.sharedMedia.append(sharedFile)
-        }
-  
-        // If this is the last item, save imagesData in userDefaults and redirect to host app
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.toData(data: this.sharedMedia), forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .media)
-        }
-        
-      } else {
-        self?.dismissWithError(message: "Cannot load video content")
+
+    if let httpResponse = response as? HTTPURLResponse {
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: HTTP Status Code: \(httpResponse.statusCode)"
+      )
+      if httpResponse.statusCode != 200 {
+        NSLog(
+          "soonlist.share-extension.shareviewcontroller: Response Headers: \(httpResponse.allHeaderFields)"
+        )
       }
     }
-  }
-  
-  private func handleFiles (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: fileURLType, options: nil) { [weak self] data, error in
-
-      if error == nil, let url = data as? URL, let this = self {
-        // Always copy
-        let fileName = this.getFileName(from :url, type: .file)
-        let fileExtension = this.getExtension(from: url, type: .file)
-        let fileSize = this.getFileSize(from: url)
-        let mimeType = url.mimeType(ext: fileExtension)
-        let newName = "\(UUID().uuidString).\(fileExtension)"
-        let newPath = FileManager.default
-          .containerURL(forSecurityApplicationGroupIdentifier: "group.\(this.hostAppBundleIdentifier)")!
-          .appendingPathComponent(newName)
-        let copied = this.copyFile(at: url, to: newPath)
-        if (copied) {
-          this.sharedMedia.append(SharedMediaFile(path: newPath.absoluteString, thumbnail: nil, fileName: fileName, fileSize: fileSize, width: nil, height: nil, duration: nil, mimeType: mimeType, type: .file))
-        }
-        
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.toData(data: this.sharedMedia), forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .file)
-        }
-        
-      } else {
-        self?.dismissWithError(message: "Cannot load file content")
-      }
+
+    guard let data = data else {
+      NSLog("soonlist.share-extension.shareviewcontroller: No data received")
+      return
     }
-  }
-  
-  private func dismissWithError(message: String? = nil) {
-    DispatchQueue.main.async {
-      NSLog("[ERROR] Error loading application ! \(message!)")
-      let alert = UIAlertController(title: "Error", message: "Error loading application: \(message!)", preferredStyle: .alert)
-    
-      let action = UIAlertAction(title: "OK", style: .cancel) { _ in
-        self.dismiss(animated: true, completion: nil)
-        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
-      }
-      
-      alert.addAction(action)
-      self.present(alert, animated: true, completion: nil)
+
+    if let responseString = String(data: data, encoding: .utf8) {
+      NSLog("soonlist.share-extension.shareviewcontroller: Response: \(responseString)")
     }
+
+    completion(.success(data))
   }
-  
-  private func redirectToHostApp(type: RedirectType) {
-    let url = URL(string: "\(shareProtocol)://dataUrl=\(sharedKey)#\(type)")!
-    var responder = self as UIResponder?
-    let selectorOpenURL = sel_registerName("openURL:")
-  
-    while (responder != nil) {
-      if let application = responder as? UIApplication {
-        if (application.canOpenURL(url)){
-          application.perform(selectorOpenURL, with: url)
-        } else {
-          NSLog("redirectToHostApp canOpenURL KO: \(shareProtocol)")
-          self.dismissWithError(message: "Application not found, invalid url scheme \(shareProtocol)")
-          return
-        }
+
+  task.resume()
+}
+
+func callAiEventFromImageThenCreateThenNotification(
+  event: PrototypeEventCreateImageSchema, completion: @escaping (Result<Data, Error>) -> Void
+) {
+  guard let domainURL = KeychainHelper.getValue(forKey: "EXPO_PUBLIC_API_BASE_URL") else {
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Failed to load EXPO_PUBLIC_API_BASE_URL from Keychain"
+    )
+    return
+  }
+
+  guard
+    let url = URL(
+      string:
+        "\(domainURL)/api/trpc/ai.eventFromImageThenCreateThenNotification"
+    )
+  else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Invalid URL")
+    return
+  }
+
+  let jsonData: Data
+  do {
+    jsonData = try JSONEncoder().encode(event)
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: JSON Payload: \(String(data: jsonData, encoding: .utf8) ?? "")"
+    )
+  } catch {
+    NSLog("soonlist.share-extension.shareviewcontroller: Error encoding JSON: \(error)")
+    return
+  }
+
+  var request = URLRequest(url: url)
+  request.httpMethod = "POST"
+  request.setValue("application/json", forHTTPHeaderField: "Content-Type")
+  request.httpBody = jsonData
+
+  let task = URLSession.shared.dataTask(with: request) { data, response, error in
+    if let error = error {
+      completion(.failure(error))
+      return
+    }
+
+    if let httpResponse = response as? HTTPURLResponse {
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: HTTP Status Code: \(httpResponse.statusCode)"
+      )
+      if httpResponse.statusCode != 200 {
+        NSLog(
+          "soonlist.share-extension.shareviewcontroller: Response Headers: \(httpResponse.allHeaderFields)"
+        )
       }
-      responder = responder!.next
     }
-    extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
-  }
-  
-  enum RedirectType {
-    case media
-    case text
-    case weburl
-    case file
-  }
-  
-  func getExtension(from url: URL, type: SharedMediaType) -> String {
-    let parts = url.lastPathComponent.components(separatedBy: ".")
-    var ex: String? = nil
-    if (parts.count > 1) {
-      ex = parts.last
+
+    guard let data = data else {
+      NSLog("soonlist.share-extension.shareviewcontroller: No data received")
+      return
     }
-    if (ex == nil) {
-      switch type {
-      case .image:
-        ex = "PNG"
-      case .video:
-        ex = "MP4"
-      case .file:
-        ex = "TXT"
-      }
+
+    if let responseString = String(data: data, encoding: .utf8) {
+      NSLog("soonlist.share-extension.shareviewcontroller: Response: \(responseString)")
     }
-    return ex ?? "Unknown"
+
+    completion(.success(data))
   }
-  
-  func getFileName(from url: URL, type: SharedMediaType) -> String {
-    var name = url.lastPathComponent
-    if (name == "") {
-      name = UUID().uuidString + "." + getExtension(from: url, type: type)
+
+  task.resume()
+}
+
+func handleImageUpload(_ imageItemProvider: NSItemProvider, completion: @escaping (String) -> Void)
+{
+  imageItemProvider.loadItem(forTypeIdentifier: UTType.image.identifier, options: nil) {
+    (imageURL, error) in
+    guard let imageURL = imageURL as? URL else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Failed to get image URL")
+      completion("")
+      return
     }
-    return name
-  }
-  
-  func getFileSize(from url: URL) -> Int? {
-    do {
-      let resources = try url.resourceValues(forKeys:[.fileSizeKey])
-      return resources.fileSize
-    } catch {
-      NSLog("Error: \(error)")
-      return nil
+
+    resizeAndUploadImage(imageURL) { imageUrl in
+      completion(imageUrl)
     }
   }
-  
-  func copyFile(at srcURL: URL, to dstURL: URL) -> Bool {
-    do {
-      if FileManager.default.fileExists(atPath: dstURL.path) {
-        try FileManager.default.removeItem(at: dstURL)
-      }
-      try FileManager.default.copyItem(at: srcURL, to: dstURL)
-    } catch (let error) {
-      NSLog("Cannot copy item at \(srcURL) to \(dstURL): \(error)")
-      return false
+}
+
+func resizeAndUploadImage(_ imageURL: URL, completion: @escaping (String) -> Void) {
+  guard let image = UIImage(contentsOfFile: imageURL.path) else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Failed to create UIImage from URL")
+    completion("")
+    return
+  }
+
+  let resizedImage = resizeImage(image, targetWidth: 1350)
+  guard let jpegData = resizedImage.jpegData(compressionQuality: 0.8) else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Failed to convert image to JPEG")
+    completion("")
+    return
+  }
+
+  uploadImage(jpegData) { imageUrl in
+    completion(imageUrl)
+  }
+}
+
+func resizeImage(_ image: UIImage, targetWidth: CGFloat) -> UIImage {
+  let aspectRatio = image.size.height / image.size.width
+  let targetHeight = targetWidth * aspectRatio
+  let newSize = CGSize(width: targetWidth, height: targetHeight)
+
+  UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
+  image.draw(in: CGRect(origin: .zero, size: newSize))
+  let resizedImage = UIGraphicsGetImageFromCurrentImageContext()!
+  UIGraphicsEndImageContext()
+
+  return resizedImage
+}
+
+func uploadImage(_ imageData: Data, completion: @escaping (String) -> Void) {
+  guard let url = URL(string: "https://api.bytescale.com/v2/accounts/12a1yek/uploads/binary") else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Invalid URL")
+    completion("")
+    return
+  }
+
+  var request = URLRequest(url: url)
+  request.httpMethod = "POST"
+  request.setValue(
+    "Bearer public_12a1yekATNiLj4VVnREZ8c7LM8V8", forHTTPHeaderField: "Authorization")
+  request.setValue("image/jpeg", forHTTPHeaderField: "Content-Type")
+  request.httpBody = imageData
+
+  let task = URLSession.shared.dataTask(with: request) { data, response, error in
+    if let error = error {
+      NSLog("soonlist.share-extension.shareviewcontroller: Error uploading image: \(error)")
+      completion("")
+      return
     }
-    return true
-  }
-  
-  private func getSharedMediaFile(forVideo: URL, fileName: String, fileSize: Int?, mimeType: String) -> SharedMediaFile? {
-    let asset = AVAsset(url: forVideo)
-    let duration = (CMTimeGetSeconds(asset.duration) * 1000).rounded()
-    let thumbnailPath = getThumbnailPath(for: forVideo)
-    
-    
-    if FileManager.default.fileExists(atPath: thumbnailPath.path) {
-      return SharedMediaFile(path: forVideo.absoluteString, thumbnail: thumbnailPath.absoluteString, fileName: fileName, fileSize: fileSize, width: nil, height: nil, duration: duration, mimeType: mimeType, type: .video)
+
+    guard let data = data else {
+      NSLog("soonlist.share-extension.shareviewcontroller: No data received from image upload")
+      completion("")
+      return
     }
-    
-    var saved = false
-    let assetImgGenerate = AVAssetImageGenerator(asset: asset)
-    assetImgGenerate.appliesPreferredTrackTransform = true
-    assetImgGenerate.maximumSize =  CGSize(width: 360, height: 360)
+
     do {
-      let img = try assetImgGenerate.copyCGImage(at: CMTimeMakeWithSeconds(600, preferredTimescale: Int32(1.0)), actualTime: nil)
-      try UIImage.pngData(UIImage(cgImage: img))()?.write(to: thumbnailPath)
-      saved = true
+      if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
+        let fileUrl = json["fileUrl"] as? String
+      {
+        NSLog("soonlist.share-extension.shareviewcontroller: Uploaded image file path: \(fileUrl)")
+        completion(fileUrl)
+      } else {
+        completion("")
+      }
     } catch {
-      saved = false
-    }
-    
-    return saved ? SharedMediaFile(path: forVideo.absoluteString, thumbnail: thumbnailPath.absoluteString, fileName: fileName, fileSize: fileSize, width: nil, height: nil, duration: duration, mimeType: mimeType, type: .video) : nil
-  }
-  
-  private func getThumbnailPath(for url: URL) -> URL {
-    let fileName = Data(url.lastPathComponent.utf8).base64EncodedString().replacingOccurrences(of: "==", with: "")
-    let path = FileManager.default
-      .containerURL(forSecurityApplicationGroupIdentifier: "group.\(hostAppBundleIdentifier)")!
-      .appendingPathComponent("\(fileName).jpg")
-    return path
-  }
-  
-  class SharedMediaFile: Codable {
-    var path: String; // can be image, video or url path
-    var thumbnail: String?; // video thumbnail
-    var fileName: String; // uuid + extension
-    var fileSize: Int?;
-    var width: Int?; // for image
-    var height: Int?; // for image
-    var duration: Double?; // video duration in milliseconds
-    var mimeType: String;
-    var type: SharedMediaType;
-    
-    init(path: String, thumbnail: String?, fileName: String, fileSize: Int?, width: Int?, height: Int?, duration: Double?, mimeType: String, type: SharedMediaType) {
-      self.path = path
-      self.thumbnail = thumbnail
-      self.fileName = fileName
-      self.fileSize = fileSize
-      self.width = width
-      self.height = height
-      self.duration = duration
-      self.mimeType = mimeType
-      self.type = type
+      NSLog("soonlist.share-extension.shareviewcontroller: Error parsing JSON response: \(error)")
+      completion("")
     }
   }
-  
-  enum SharedMediaType: Int, Codable {
-    case image
-    case video
-    case file
+
+  task.resume()
+}
+
+struct PrototypeEventCreateRawTextSchema: Codable {
+  let json: EventData
+
+  struct EventData: Codable {
+    let rawText: String
+    let timezone: String
+    let expoPushToken: String
+    let lists: [String]
+    let userId: String
+    let username: String
+  }
+}
+
+struct PrototypeEventCreateImageSchema: Codable {
+  let json: EventData
+
+  struct EventData: Codable {
+    let imageUrl: String
+    let timezone: String
+    let expoPushToken: String
+    let lists: [String]
+    let userId: String
+    let username: String
   }
-  
-  func toData(data: [SharedMediaFile]) -> Data {
-    let encodedData = try? JSONEncoder().encode(data)
-    return encodedData!
+}
+
+class KeychainHelper {
+  static func getValue(forKey key: String) -> String? {
+    let query: [String: Any] = [
+      kSecClass as String: kSecClassGenericPassword,
+      kSecAttrService as String: "app:no-auth",
+      kSecAttrAccount as String: key,
+      kSecReturnData as String: true,
+      kSecAttrAccessGroup as String: "group.soonlist.soonlist",
+    ]
+
+    var item: CFTypeRef?
+    let status = SecItemCopyMatching(query as CFDictionary, &item)
+
+    guard status == errSecSuccess,
+      let data = item as? Data,
+      let value = String(data: data, encoding: .utf8)
+    else {
+      return nil
+    }
+
+    return value
   }
 }
 
-internal let mimeTypes = [
-    "html": "text/html",
-    "htm": "text/html",
-    "shtml": "text/html",
-    "css": "text/css",
-    "xml": "text/xml",
-    "gif": "image/gif",
-    "jpeg": "image/jpeg",
-    "jpg": "image/jpeg",
-    "js": "application/javascript",
-    "atom": "application/atom+xml",
-    "rss": "application/rss+xml",
-    "mml": "text/mathml",
-    "txt": "text/plain",
-    "jad": "text/vnd.sun.j2me.app-descriptor",
-    "wml": "text/vnd.wap.wml",
-    "htc": "text/x-component",
-    "png": "image/png",
-    "tif": "image/tiff",
-    "tiff": "image/tiff",
-    "wbmp": "image/vnd.wap.wbmp",
-    "ico": "image/x-icon",
-    "jng": "image/x-jng",
-    "bmp": "image/x-ms-bmp",
-    "svg": "image/svg+xml",
-    "svgz": "image/svg+xml",
-    "webp": "image/webp",
-    "woff": "application/font-woff",
-    "jar": "application/java-archive",
-    "war": "application/java-archive",
-    "ear": "application/java-archive",
-    "json": "application/json",
-    "hqx": "application/mac-binhex40",
-    "doc": "application/msword",
-    "pdf": "application/pdf",
-    "ps": "application/postscript",
-    "eps": "application/postscript",
-    "ai": "application/postscript",
-    "rtf": "application/rtf",
-    "m3u8": "application/vnd.apple.mpegurl",
-    "xls": "application/vnd.ms-excel",
-    "eot": "application/vnd.ms-fontobject",
-    "ppt": "application/vnd.ms-powerpoint",
-    "wmlc": "application/vnd.wap.wmlc",
-    "kml": "application/vnd.google-earth.kml+xml",
-    "kmz": "application/vnd.google-earth.kmz",
-    "7z": "application/x-7z-compressed",
-    "cco": "application/x-cocoa",
-    "jardiff": "application/x-java-archive-diff",
-    "jnlp": "application/x-java-jnlp-file",
-    "run": "application/x-makeself",
-    "pl": "application/x-perl",
-    "pm": "application/x-perl",
-    "prc": "application/x-pilot",
-    "pdb": "application/x-pilot",
-    "rar": "application/x-rar-compressed",
-    "rpm": "application/x-redhat-package-manager",
-    "sea": "application/x-sea",
-    "swf": "application/x-shockwave-flash",
-    "sit": "application/x-stuffit",
-    "tcl": "application/x-tcl",
-    "tk": "application/x-tcl",
-    "der": "application/x-x509-ca-cert",
-    "pem": "application/x-x509-ca-cert",
-    "crt": "application/x-x509-ca-cert",
-    "xpi": "application/x-xpinstall",
-    "xhtml": "application/xhtml+xml",
-    "xspf": "application/xspf+xml",
-    "zip": "application/zip",
-    "epub": "application/epub+zip",
-    "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
-    "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
-    "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
-    "mid": "audio/midi",
-    "midi": "audio/midi",
-    "kar": "audio/midi",
-    "mp3": "audio/mpeg",
-    "ogg": "audio/ogg",
-    "m4a": "audio/x-m4a",
-    "ra": "audio/x-realaudio",
-    "3gpp": "video/3gpp",
-    "3gp": "video/3gpp",
-    "ts": "video/mp2t",
-    "mp4": "video/mp4",
-    "mpeg": "video/mpeg",
-    "mpg": "video/mpeg",
-    "mov": "video/quicktime",
-    "webm": "video/webm",
-    "flv": "video/x-flv",
-    "m4v": "video/x-m4v",
-    "mng": "video/x-mng",
-    "asx": "video/x-ms-asf",
-    "asf": "video/x-ms-asf",
-    "wmv": "video/x-ms-wmv",
-    "avi": "video/x-msvideo"
-]
-
-extension URL {
-  func mimeType(ext: String?) -> String {
-    if #available(iOSApplicationExtension 14.0, *) {
-      if let pathExt = ext,
-        let mimeType = UTType(filenameExtension: pathExt)?.preferredMIMEType {
-        return mimeType
-      } else {
-        return "application/octet-stream"
+func loadAuthData() -> AuthData? {
+  NSLog("soonlist.share-extension.shareviewcontroller: Attempting to load auth data from Keychain")
+
+  logAllKeys()
+
+  let query: [String: Any] = [
+    kSecClass as String: kSecClassGenericPassword,
+    kSecAttrAccessGroup as String: "group.soonlist.soonlist",
+    kSecReturnData as String: false,
+  ]
+
+  let status = SecItemCopyMatching(query as CFDictionary, nil)
+
+  switch status {
+  case errSecSuccess:
+    NSLog("soonlist.share-extension.shareviewcontroller: Keychain is accessible")
+  case errSecItemNotFound:
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Keychain item not found. This may be normal if no data has been saved yet."
+    )
+  case errSecInteractionNotAllowed:
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Keychain access not allowed. This might be due to device lock state."
+    )
+  case errSecAuthFailed:
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Keychain authentication failed. Check entitlements and provisioning profile."
+    )
+  default:
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Keychain is not accessible. Error: \(status)")
+  }
+
+  guard status == errSecSuccess else {
+    return nil
+  }
+
+  guard let authDataString = KeychainHelper.getValue(forKey: "authData") else {
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Failed to retrieve authData string from Keychain"
+    )
+    return nil
+  }
+
+  NSLog(
+    "soonlist.share-extension.shareviewcontroller: Retrieved authData string: \(authDataString)")
+
+  guard let authDataData = authDataString.data(using: .utf8) else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Failed to convert authData string to Data")
+    return nil
+  }
+
+  do {
+    if let authData = try JSONSerialization.jsonObject(with: authDataData, options: [])
+      as? [String: String]
+    {
+      NSLog("soonlist.share-extension.shareviewcontroller: Successfully parsed authData JSON")
+
+      guard let userId = authData["userId"],
+        let username = authData["username"],
+        let authToken = authData["authToken"],
+        let expoPushToken = authData["expoPushToken"]
+      else {
+        NSLog(
+          "soonlist.share-extension.shareviewcontroller: One or more required fields not found in authData"
+        )
+        return nil
       }
+
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: Successfully retrieved all required fields from authData"
+      )
+      return AuthData(
+        userId: userId, username: username, authToken: authToken, expoPushToken: expoPushToken)
     } else {
-      return mimeTypes[ext?.lowercased() ?? "" ] ?? "application/octet-stream"
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: Failed to cast parsed JSON to [String: String]"
+      )
     }
+  } catch {
+    NSLog("soonlist.share-extension.shareviewcontroller: Error parsing authData JSON: \(error)")
   }
+
+  NSLog("soonlist.share-extension.shareviewcontroller: Failed to load auth data")
+  return nil
 }
 
-extension Array {
-  subscript (safe index: UInt) -> Element? {
-    return Int(index) < count ? self[Int(index)] : nil
+func logAllKeys() {
+  NSLog("soonlist.share-extension.shareviewcontroller: Attempting to log all keychain items")
+
+  let query: [String: Any] = [
+    kSecClass as String: kSecClassGenericPassword,
+    kSecReturnData as String: true,
+    kSecReturnAttributes as String: true,
+    kSecMatchLimit as String: kSecMatchLimitAll,
+  ]
+
+  var item: CFTypeRef?
+  let status = SecItemCopyMatching(query as CFDictionary, &item)
+
+  guard status != errSecItemNotFound else {
+    NSLog("soonlist.share-extension.shareviewcontroller: No keychain items found")
+    return
+  }
+
+  guard status == errSecSuccess else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Error fetching keychain items: \(status)")
+    return
+  }
+
+  guard let existingItems = item as? [[String: Any]] else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Unexpected result type")
+    return
+  }
+
+  for (index, existingItem) in existingItems.enumerated() {
+    let account = existingItem[kSecAttrAccount as String] as? String ?? "Unknown Account"
+    let passwordData = existingItem[kSecValueData as String] as? Data
+    let password =
+      passwordData != nil
+      ? String(data: passwordData!, encoding: .utf8) ?? "Unable to decode" : "No password data"
+
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Item \(index + 1): Account: \(account), Password: \(password)"
+    )
+
+    // Log all attributes for debugging
+    for (key, value) in existingItem {
+      NSLog("soonlist.share-extension.shareviewcontroller: Item \(index + 1) - \(key): \(value)")
+    }
   }
 }
diff --git a/plugin/build/ios/withIosShareExtensionXcodeTarget.js b/plugin/build/ios/withIosShareExtensionXcodeTarget.js
index 9d192ccaebf4bae7195d1e735f5aef67a8283461..0593f3f5253da74272c711a7796ad7bb895e2658 100644
--- a/plugin/build/ios/withIosShareExtensionXcodeTarget.js
+++ b/plugin/build/ios/withIosShareExtensionXcodeTarget.js
@@ -61,6 +61,7 @@ const withShareExtensionXcodeTarget = (config, parameters) => {
                     buildSettingsObj["SWIFT_EMIT_LOC_STRINGS"] = "YES";
                     buildSettingsObj["SWIFT_VERSION"] = "5.0";
                     buildSettingsObj["TARGETED_DEVICE_FAMILY"] = `"1,2"`;
+                    buildSettingsObj["IPHONEOS_DEPLOYMENT_TARGET"] = "15.0";
                 }
             }
         }

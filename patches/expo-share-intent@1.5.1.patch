diff --git a/ios/ExpoShareIntentModule.podspec b/ios/ExpoShareIntentModule.podspec
index 6db146996720008f9ce6f1809b6ec7f6951a78e9..26b0f73292f3b34ae5a6e07f6288128f8ff0a05b 100644
--- a/ios/ExpoShareIntentModule.podspec
+++ b/ios/ExpoShareIntentModule.podspec
@@ -10,12 +10,13 @@ Pod::Spec.new do |s|
   s.license        = package['license']
   s.author         = package['author']
   s.homepage       = package['homepage']
-  s.platform       = :ios, '13.0'
+  s.platform       = :ios, '15.0'
   s.swift_version  = '5.4'
   s.source         = { git: 'https://github.com/achorein/expo-share-intent' }
   s.static_framework = true
 
   s.dependency 'ExpoModulesCore'
+  s.dependency 'Sentry', '8.21.0'
 
   # Swift/Objective-C compatibility
   s.pod_target_xcconfig = {
diff --git a/plugin/build/ios/ShareExtensionViewController.swift b/plugin/build/ios/ShareExtensionViewController.swift
index 67036867bd4a082140d2f8ae5000caea9cdb50fb..97267e89a9275c14029ddd4b249a8da84076aaac 100644
--- a/plugin/build/ios/ShareExtensionViewController.swift
+++ b/plugin/build/ios/ShareExtensionViewController.swift
@@ -1,496 +1,751 @@
-/*!
- * Native module created for Expo Share Intent (https://github.com/achorein/expo-share-intent)
- * author: achorein (https://github.com/achorein)
- * inspired by :
- *  - https://ajith-ab.github.io/react-native-receive-sharing-intent/docs/ios#create-share-extension
- */
-import UIKit
-import Social
 import MobileCoreServices
 import Photos
+import Security
+import Social
+import UIKit
+import UniformTypeIdentifiers
+import os.log
+import UserNotifications
+import Sentry
 
-class ShareViewController: SLComposeServiceViewController {
-  let hostAppBundleIdentifier = "<APPIDENTIFIER>"
-  let shareProtocol = "<SCHEME>"
-  let sharedKey = "<SCHEME>ShareKey"
-  var sharedMedia: [SharedMediaFile] = []
-  var sharedText: [String] = []
+struct AuthData {
+  let userId: String
+  let username: String
+  let authToken: String
+  let expoPushToken: String
+}
+
+class ShareViewController: UIViewController {
   let imageContentType = kUTTypeImage as String
   let videoContentType = kUTTypeMovie as String
   let textContentType = kUTTypeText as String
   let urlContentType = kUTTypeURL as String
-  let fileURLType = kUTTypeFileURL as String;
-  
-  override func isContentValid() -> Bool {
-    return true
-  }
-      
+  let fileURLType = kUTTypeFileURL as String
+
   override func viewDidLoad() {
-    super.viewDidLoad();
+    super.viewDidLoad()
+    
+    SentrySDK.start { options in
+      options.dsn = "https://35d541c34f3a87134429ac75e6513a16@o4503934125998080.ingest.us.sentry.io/4506458761396224",
+      options.debug = true // Set to false in production
+      options.enableAutoSessionTracking = true
+    }
   }
-      
+
   override func viewDidAppear(_ animated: Bool) {
     super.viewDidAppear(animated)
+    NSLog("soonlist.share-extension.shareviewcontroller: viewDidAppear called")
+
+    // Dismiss the UI
+    self.dismiss(animated: true) {
+      NSLog("soonlist.share-extension.shareviewcontroller: Dismissed UI")
+    }
+    
+    // Perform the share operation in the background
+    DispatchQueue.global(qos: .userInitiated).async {
+      NSLog("soonlist.share-extension.shareviewcontroller: Performing share operation in the background")
+      self.performShare()
+
+      // Complete the request when done
+      DispatchQueue.main.async {
+        NSLog("soonlist.share-extension.shareviewcontroller: Completing request on the main queue")
+        self.extensionContext?.completeRequest(returningItems: [], completionHandler: nil)
+      }
+    }
+  }
+
+  func performShare() {
+    NSLog("soonlist.share-extension.shareviewcontroller: Attempting to perform share")
+    guard let authData = loadAuthData() else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Failed to load auth data in performShare()")
+      sendLoginNotification()
+      return
+    }
+
+    if authData.userId.isEmpty || authData.username.isEmpty || authData.authToken.isEmpty {
+      NSLog("soonlist.share-extension.shareviewcontroller: User ID or username or auth token is empty")
+      sendLoginNotification()
+      return
+    }
+
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Successfully loaded auth data: userId=\(authData.userId), username=\(authData.username)"
+    )
+
+    logExtensionContext()
+
     if let content = extensionContext!.inputItems[0] as? NSExtensionItem {
       if let contents = content.attachments {
         for (index, attachment) in (contents).enumerated() {
+          NSLog("soonlist.share-extension.shareviewcontroller: Processing attachment at index \(index)")
           if attachment.hasItemConformingToTypeIdentifier(imageContentType) {
-            handleImages(content: content, attachment: attachment, index: index)
+            NSLog("soonlist.share-extension.shareviewcontroller: Attachment is an image")
+            handleImages(content: content, attachment: attachment, index: index, authData: authData)
           } else if attachment.hasItemConformingToTypeIdentifier(textContentType) {
-            handleText(content: content, attachment: attachment, index: index)
+            NSLog("soonlist.share-extension.shareviewcontroller: Attachment is text")
+            handleText(content: content, attachment: attachment, index: index, authData: authData)
           } else if attachment.hasItemConformingToTypeIdentifier(fileURLType) {
-            handleFiles(content: content, attachment: attachment, index: index)
+            NSLog("soonlist.share-extension.shareviewcontroller: Attachment is a file URL")
+            handleUnsupportedType(type: "fileURL")
           } else if attachment.hasItemConformingToTypeIdentifier(urlContentType) {
-            handleUrl(content: content, attachment: attachment, index: index)
+            NSLog("soonlist.share-extension.shareviewcontroller: Attachment is a URL")
+            handleUnsupportedType(type: "url")
           } else if attachment.hasItemConformingToTypeIdentifier(videoContentType) {
-            handleVideos(content: content, attachment: attachment, index: index)
+            NSLog("soonlist.share-extension.shareviewcontroller: Attachment is a video")
+            handleUnsupportedType(type: "video")
+          } else {
+            NSLog("soonlist.share-extension.shareviewcontroller: Attachment is of unknown type")
+            handleUnsupportedType(type: "unknown")
           }
         }
+      } else {
+        NSLog("soonlist.share-extension.shareviewcontroller: No attachments found in the extension item")
       }
+    } else {
+      NSLog("soonlist.share-extension.shareviewcontroller: No input items found in the extension context")
     }
   }
-  
-  private func handleText (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: textContentType, options: nil) { [weak self] data, error in
-      
-      if error == nil, let item = data as? String, let this = self {
-        this.sharedText.append(item)
-          
-        // If this is the last item, save sharedText in userDefaults and redirect to host app
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.sharedText, forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .text)
+
+  private func logExtensionContext() {
+    if let context = self.extensionContext {
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: Extension context - input items count: \(context.inputItems.count)"
+      )
+      for (index, item) in context.inputItems.enumerated() {
+        if let extensionItem = item as? NSExtensionItem {
+          NSLog(
+            "soonlist.share-extension.shareviewcontroller: Input item \(index) - attachments count: \(extensionItem.attachments?.count ?? 0)"
+          )
+          NSLog(
+            "soonlist.share-extension.shareviewcontroller: Input item \(index) - attributed content text: \(extensionItem.attributedContentText?.string ?? "nil")"
+          )
         }
-              
-      } else {
-        self?.dismissWithError(message: "Cannot load text content")
       }
+    } else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Extension context is nil")
     }
   }
-              
-  private func handleUrl (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: urlContentType, options: nil) { [weak self] data, error in
-
-      if error == nil, let item = data as? URL, let this = self {
-        this.sharedText.append(item.absoluteString)
-        
-        // If this is the last item, save sharedText in userDefaults and redirect to host app
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.sharedText, forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .weburl)
+
+  private func handleImages(
+    content: NSExtensionItem, attachment: NSItemProvider, index: Int, authData: AuthData
+  ) {
+    NSLog("soonlist.share-extension.shareviewcontroller: Performing automatic share with image")
+    attachment.loadItem(forTypeIdentifier: imageContentType, options: nil) {
+      [weak self] (imageData, error) in
+      guard let self = self else { return }
+      if let error = error {
+        NSLog("soonlist.share-extension.shareviewcontroller: Error loading image data: \(error)")
+        self.sendFailureNotification(authData: authData)
+        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
+        return
+      }
+      
+      if let imageUrl = imageData as? URL {
+        NSLog("soonlist.share-extension.shareviewcontroller: Image data loaded as URL: \(imageUrl)")
+        self.resizeAndUploadImage(imageUrl) { uploadedImageUrl in
+          guard !uploadedImageUrl.isEmpty else {
+            NSLog("soonlist.share-extension.shareviewcontroller: Failed to upload image")
+            self.sendFailureNotification(authData: authData)
+            self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
+            return
+          }
+
+          NSLog("soonlist.share-extension.shareviewcontroller: Image uploaded successfully: \(uploadedImageUrl)")
+
+          let event = PrototypeEventCreateImageSchema(
+            json: PrototypeEventCreateImageSchema.EventData(
+              imageUrl: uploadedImageUrl,
+              timezone: TimeZone.current.identifier,
+              expoPushToken: authData.expoPushToken,
+              lists: [],
+              userId: authData.userId,
+              username: authData.username
+            )
+          )
+
+          self.callAiEventFromImageThenCreateThenNotification(event: event) { result in
+            switch result {
+            case .success(let data):
+              NSLog(
+                "soonlist.share-extension.shareviewcontroller: Success: \(String(data: data, encoding: .utf8) ?? "")"
+              )
+            case .failure(let error):
+              NSLog("soonlist.share-extension.shareviewcontroller: Error: \(error)")
+              self.sendFailureNotification(authData: authData)
+            }
+
+            self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
+          }
         }
       } else {
-        self?.dismissWithError(message: "Cannot load url content")
+        NSLog("soonlist.share-extension.shareviewcontroller: Failed to load image data")
+        self.sendFailureNotification(authData: authData)
+        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
       }
-
     }
   }
-  
-  private func handleImages (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: imageContentType, options: nil) { [weak self] data, error in
-
-      if error == nil, let this = self {
-        var url: URL? = nil
-        if let dataURL = data as? URL { url = dataURL }
-        else if let imageData = data as? UIImage { url = this.saveScreenshot(imageData) }
-
-        var pixelWidth: Int? = nil
-        var pixelHeight: Int? = nil
-        if let imageSource = CGImageSourceCreateWithURL(url! as CFURL, nil) {
-            if let imageProperties = CGImageSourceCopyPropertiesAtIndex(imageSource, 0, nil) as Dictionary? {
-              pixelWidth = imageProperties[kCGImagePropertyPixelWidth] as? Int
-              pixelHeight = imageProperties[kCGImagePropertyPixelHeight] as? Int
-            }
-        }
 
-        // Always copy
-        let fileName = this.getFileName(from :url!, type: .image)
-        let fileExtension = this.getExtension(from: url!, type: .image)
-        let fileSize = this.getFileSize(from: url!)
-        let mimeType = url!.mimeType(ext: fileExtension)
-        let newName = "\(UUID().uuidString).\(fileExtension)"
-        let newPath = FileManager.default
-          .containerURL(forSecurityApplicationGroupIdentifier: "group.\(this.hostAppBundleIdentifier)")!
-          .appendingPathComponent(newName)
-        let copied = this.copyFile(at: url!, to: newPath)
-        if(copied) {
-          this.sharedMedia.append(SharedMediaFile(path: newPath.absoluteString, thumbnail: nil, fileName: fileName, fileSize: fileSize, width: pixelWidth, height: pixelHeight,  duration: nil, mimeType: mimeType, type: .image))
-        }
-  
-        // If this is the last item, save imagesData in userDefaults and redirect to host app
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.toData(data: this.sharedMedia), forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .media)
+  private func handleText(
+    content: NSExtensionItem, attachment: NSItemProvider, index: Int, authData: AuthData
+  ) {
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Performing automatic share with raw text")
+    attachment.loadItem(forTypeIdentifier: textContentType, options: nil) {
+      [weak self] (textData, error) in
+      guard let self = self else { return }
+      if let error = error {
+        NSLog("soonlist.share-extension.shareviewcontroller: Error loading text data: \(error)")
+        self.sendFailureNotification(authData: authData)
+        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
+        return
+      }
+      
+      let rawText =
+        (textData as? String) ?? content.attributedContentText?.string ?? "Event details"
+      NSLog("soonlist.share-extension.shareviewcontroller: Raw text: \(rawText)")
+      
+      let event = PrototypeEventCreateRawTextSchema(
+        json: PrototypeEventCreateRawTextSchema.EventData(
+          rawText: rawText,
+          timezone: TimeZone.current.identifier,
+          expoPushToken: authData.expoPushToken,
+          lists: [],
+          userId: authData.userId,
+          username: authData.username
+        )
+      )
+
+      self.callAiEventFromRawTextThenCreateThenNotification(event: event) { result in
+        switch result {
+        case .success(let data):
+          NSLog(
+            "soonlist.share-extension.shareviewcontroller: Success: \(String(data: data, encoding: .utf8) ?? "")"
+          )
+        case .failure(let error):
+          NSLog("soonlist.share-extension.shareviewcontroller: Error: \(error)")
+          self.sendFailureNotification(authData: authData)
         }
-        
-      } else {
-        self?.dismissWithError(message: "Cannot load image content")
+
+        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
       }
     }
   }
-  
-  private func documentDirectoryPath () -> URL?  {
-    let path = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)
-    return path.first
+
+  private func handleUnsupportedType(type: String) {
+    NSLog("soonlist.share-extension.shareviewcontroller: Unsupported share type: \(type)")
   }
 
-  private func saveScreenshot(_ image: UIImage) -> URL? {
-    var screenshotURL: URL? = nil
-    if let screenshotData = image.pngData(), let screenshotPath = documentDirectoryPath()?.appendingPathComponent("screenshot.png") {
-      try? screenshotData.write(to: screenshotPath)
-      screenshotURL = screenshotPath
+  // Define the method to call the API
+  private func callAiEventFromRawTextThenCreateThenNotification(
+    event: PrototypeEventCreateRawTextSchema, completion: @escaping (Result<Data, Error>) -> Void
+  ) {
+    NSLog("soonlist.share-extension.shareviewcontroller: Calling AI event from raw text")
+    guard let domainURL = KeychainHelper.getValue(forKey: "EXPO_PUBLIC_API_BASE_URL") else {
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: Failed to load EXPO_PUBLIC_API_BASE_URL from Keychain"
+      )
+      return
     }
-    return screenshotURL
-  }
 
-  private func handleVideos (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: videoContentType, options:nil) { [weak self] data, error in
-      
-      if error == nil, let url = data as? URL, let this = self {
-        
-        // Always copy
-        let fileName = this.getFileName(from :url, type: .video)
-        let fileExtension = this.getExtension(from: url, type: .video)
-        let fileSize = this.getFileSize(from: url)
-        let mimeType = url.mimeType(ext: fileExtension)
-        let newName = "\(UUID().uuidString).\(fileExtension)"
-        let newPath = FileManager.default
-          .containerURL(forSecurityApplicationGroupIdentifier: "group.\(this.hostAppBundleIdentifier)")!
-          .appendingPathComponent(newName)
-        let copied = this.copyFile(at: url, to: newPath)
-        if(copied) {
-          guard let sharedFile = this.getSharedMediaFile(forVideo: newPath, fileName: fileName, fileSize: fileSize, mimeType: mimeType) else {
-            return
-          }
-          this.sharedMedia.append(sharedFile)
-        }
-  
-        // If this is the last item, save imagesData in userDefaults and redirect to host app
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.toData(data: this.sharedMedia), forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .media)
+    guard
+      let url = URL(
+        string:
+          "\(domainURL)/api/trpc/ai.eventFromRawTextThenCreateThenNotification"
+      )
+    else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Invalid URL")
+      return
+    }
+
+    let jsonData: Data
+    do {
+      jsonData = try JSONEncoder().encode(event)
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: JSON Payload: \(String(data: jsonData, encoding: .utf8) ?? "")"
+      )
+    } catch {
+      NSLog("soonlist.share-extension.shareviewcontroller: Error encoding JSON: \(error)")
+      return
+    }
+
+    var request = URLRequest(url: url)
+    request.httpMethod = "POST"
+    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
+
+    let task = URLSession.shared.uploadTask(with: request, from: jsonData) { data, response, error in
+      if let error = error {
+        NSLog("soonlist.share-extension.shareviewcontroller: Error in upload task: \(error)")
+        completion(.failure(error))
+        return
+      }
+
+      if let httpResponse = response as? HTTPURLResponse {
+        NSLog(
+          "soonlist.share-extension.shareviewcontroller: HTTP Status Code: \(httpResponse.statusCode)"
+        )
+        if httpResponse.statusCode != 200 {
+          NSLog(
+            "soonlist.share-extension.shareviewcontroller: Response Headers: \(httpResponse.allHeaderFields)"
+          )
         }
-        
-      } else {
-        self?.dismissWithError(message: "Cannot load video content")
       }
+
+      guard let data = data else {
+        NSLog("soonlist.share-extension.shareviewcontroller: No data received")
+        return
+      }
+
+      if let responseString = String(data: data, encoding: .utf8) {
+        NSLog("soonlist.share-extension.shareviewcontroller: Response: \(responseString)")
+      }
+
+      completion(.success(data))
     }
+
+    task.resume()
   }
-  
-  private func handleFiles (content: NSExtensionItem, attachment: NSItemProvider, index: Int) {
-    attachment.loadItem(forTypeIdentifier: fileURLType, options: nil) { [weak self] data, error in
-
-      if error == nil, let url = data as? URL, let this = self {
-        // Always copy
-        let fileName = this.getFileName(from :url, type: .file)
-        let fileExtension = this.getExtension(from: url, type: .file)
-        let fileSize = this.getFileSize(from: url)
-        let mimeType = url.mimeType(ext: fileExtension)
-        let newName = "\(UUID().uuidString).\(fileExtension)"
-        let newPath = FileManager.default
-          .containerURL(forSecurityApplicationGroupIdentifier: "group.\(this.hostAppBundleIdentifier)")!
-          .appendingPathComponent(newName)
-        let copied = this.copyFile(at: url, to: newPath)
-        if (copied) {
-          this.sharedMedia.append(SharedMediaFile(path: newPath.absoluteString, thumbnail: nil, fileName: fileName, fileSize: fileSize, width: nil, height: nil, duration: nil, mimeType: mimeType, type: .file))
-        }
-        
-        if index == (content.attachments?.count)! - 1 {
-          let userDefaults = UserDefaults(suiteName: "group.\(this.hostAppBundleIdentifier)")
-          userDefaults?.set(this.toData(data: this.sharedMedia), forKey: this.sharedKey)
-          userDefaults?.synchronize()
-          this.redirectToHostApp(type: .file)
+
+  func callAiEventFromImageThenCreateThenNotification(
+    event: PrototypeEventCreateImageSchema, completion: @escaping (Result<Data, Error>) -> Void
+  ) {
+    NSLog("soonlist.share-extension.shareviewcontroller: Calling AI event from image")
+    guard let domainURL = KeychainHelper.getValue(forKey: "EXPO_PUBLIC_API_BASE_URL") else {
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: Failed to load EXPO_PUBLIC_API_BASE_URL from Keychain"
+      )
+      return
+    }
+
+    guard
+      let url = URL(
+        string:
+          "\(domainURL)/api/trpc/ai.eventFromImageThenCreateThenNotification"
+      )
+    else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Invalid URL")
+      return
+    }
+
+    let jsonData: Data
+    do {
+      jsonData = try JSONEncoder().encode(event)
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: JSON Payload: \(String(data: jsonData, encoding: .utf8) ?? "")"
+      )
+    } catch {
+      NSLog("soonlist.share-extension.shareviewcontroller: Error encoding JSON: \(error)")
+      return
+    }
+
+    var request = URLRequest(url: url)
+    request.httpMethod = "POST"
+    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
+
+    let task = URLSession.shared.uploadTask(with: request, from: jsonData) { data, response, error in
+      if let error = error {
+        NSLog("soonlist.share-extension.shareviewcontroller: Error in upload task: \(error)")
+        completion(.failure(error))
+        return
+      }
+
+      if let httpResponse = response as? HTTPURLResponse {
+        NSLog(
+          "soonlist.share-extension.shareviewcontroller: HTTP Status Code: \(httpResponse.statusCode)"
+        )
+        if httpResponse.statusCode != 200 {
+          NSLog(
+            "soonlist.share-extension.shareviewcontroller: Response Headers: \(httpResponse.allHeaderFields)"
+          )
         }
-        
-      } else {
-        self?.dismissWithError(message: "Cannot load file content")
       }
+
+      guard let data = data else {
+        NSLog("soonlist.share-extension.shareviewcontroller: No data received")
+        return
+      }
+
+      if let responseString = String(data: data, encoding: .utf8) {
+        NSLog("soonlist.share-extension.shareviewcontroller: Response: \(responseString)")
+      }
+
+      completion(.success(data))
     }
+
+    task.resume()
   }
-  
-  private func dismissWithError(message: String? = nil) {
-    DispatchQueue.main.async {
-      NSLog("[ERROR] Error loading application ! \(message!)")
-      let alert = UIAlertController(title: "Error", message: "Error loading application: \(message!)", preferredStyle: .alert)
-    
-      let action = UIAlertAction(title: "OK", style: .cancel) { _ in
-        self.dismiss(animated: true, completion: nil)
-        self.extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
+
+  private func handleImageUpload(
+    _ imageItemProvider: NSItemProvider, completion: @escaping (String) -> Void
+  ) {
+    imageItemProvider.loadItem(forTypeIdentifier: UTType.image.identifier, options: nil) {
+      (imageURL, error) in
+      guard let imageURL = imageURL as? URL else {
+        NSLog("soonlist.share-extension.shareviewcontroller: Failed to get image URL")
+        completion("")
+        return
+      }
+
+      self.resizeAndUploadImage(imageURL) { imageUrl in
+        completion(imageUrl)
       }
-      
-      alert.addAction(action)
-      self.present(alert, animated: true, completion: nil)
     }
   }
-  
-  private func redirectToHostApp(type: RedirectType) {
-    let url = URL(string: "\(shareProtocol)://dataUrl=\(sharedKey)#\(type)")!
-    var responder = self as UIResponder?
-    let selectorOpenURL = sel_registerName("openURL:")
-  
-    while (responder != nil) {
-      if let application = responder as? UIApplication {
-        if (application.canOpenURL(url)){
-          application.perform(selectorOpenURL, with: url)
-        } else {
-          NSLog("redirectToHostApp canOpenURL KO: \(shareProtocol)")
-          self.dismissWithError(message: "Application not found, invalid url scheme \(shareProtocol)")
-          return
-        }
-      }
-      responder = responder!.next
+
+  private func resizeAndUploadImage(_ imageURL: URL, completion: @escaping (String) -> Void) {
+    NSLog("soonlist.share-extension.shareviewcontroller: Resizing and uploading image")
+    guard let image = UIImage(contentsOfFile: imageURL.path) else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Failed to create UIImage from URL")
+      completion("")
+      return
+    }
+
+    let resizedImage = resizeImage(image, targetWidth: 1350)
+    guard let jpegData = resizedImage.jpegData(compressionQuality: 0.8) else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Failed to convert image to JPEG")
+      completion("")
+      return
+    }
+
+    uploadImage(jpegData) { imageUrl in
+      NSLog("soonlist.share-extension.shareviewcontroller: Image uploaded: \(imageUrl)")
+      completion(imageUrl)
     }
-    extensionContext!.completeRequest(returningItems: [], completionHandler: nil)
   }
-  
-  enum RedirectType {
-    case media
-    case text
-    case weburl
-    case file
+
+  private func resizeImage(_ image: UIImage, targetWidth: CGFloat) -> UIImage {
+    let aspectRatio = image.size.height / image.size.width
+    let targetHeight = targetWidth * aspectRatio
+    let newSize = CGSize(width: targetWidth, height: targetHeight)
+
+    UIGraphicsBeginImageContextWithOptions(newSize, false, 1.0)
+    image.draw(in: CGRect(origin: .zero, size: newSize))
+    let resizedImage = UIGraphicsGetImageFromCurrentImageContext()!
+    UIGraphicsEndImageContext()
+
+    return resizedImage
   }
-  
-  func getExtension(from url: URL, type: SharedMediaType) -> String {
-    let parts = url.lastPathComponent.components(separatedBy: ".")
-    var ex: String? = nil
-    if (parts.count > 1) {
-      ex = parts.last
-    }
-    if (ex == nil) {
-      switch type {
-      case .image:
-        ex = "PNG"
-      case .video:
-        ex = "MP4"
-      case .file:
-        ex = "TXT"
+
+  private func uploadImage(_ imageData: Data, completion: @escaping (String) -> Void) {
+    NSLog("soonlist.share-extension.shareviewcontroller: Uploading image")
+    guard let url = URL(string: "https://api.bytescale.com/v2/accounts/12a1yek/uploads/binary")
+    else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Invalid URL")
+      completion("")
+      return
+    }
+
+    var request = URLRequest(url: url)
+    request.httpMethod = "POST"
+    request.setValue(
+      "Bearer public_12a1yekATNiLj4VVnREZ8c7LM8V8", forHTTPHeaderField: "Authorization")
+    request.setValue("image/jpeg", forHTTPHeaderField: "Content-Type")
+
+    let task = URLSession.shared.uploadTask(with: request, from: imageData) { data, response, error in
+      if let error = error {
+        NSLog("soonlist.share-extension.shareviewcontroller: Error uploading image: \(error)")
+        completion("")
+        return
+      }
+
+      guard let data = data else {
+        NSLog("soonlist.share-extension.shareviewcontroller: No data received from image upload")
+        completion("")
+        return
+      }
+
+      do {
+        if let json = try JSONSerialization.jsonObject(with: data, options: []) as? [String: Any],
+          let fileUrl = json["fileUrl"] as? String
+        {
+          NSLog(
+            "soonlist.share-extension.shareviewcontroller: Uploaded image file path: \(fileUrl)")
+          completion(fileUrl)
+        } else {
+          completion("")
+        }
+      } catch {
+        NSLog("soonlist.share-extension.shareviewcontroller: Error parsing JSON response: \(error)")
+        completion("")
       }
     }
-    return ex ?? "Unknown"
+
+    task.resume()
   }
-  
-  func getFileName(from url: URL, type: SharedMediaType) -> String {
-    var name = url.lastPathComponent
-    if (name == "") {
-      name = UUID().uuidString + "." + getExtension(from: url, type: type)
+
+  // Add this new method
+  private func sendLoginNotification() {
+    NSLog("soonlist.share-extension.shareviewcontroller: Sending login notification")
+    guard let domainURL = KeychainHelper.getValue(forKey: "EXPO_PUBLIC_API_BASE_URL") else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Failed to load EXPO_PUBLIC_API_BASE_URL from Keychain")
+      return
     }
-    return name
-  }
-  
-  func getFileSize(from url: URL) -> Int? {
-    do {
-      let resources = try url.resourceValues(forKeys:[.fileSizeKey])
-      return resources.fileSize
-    } catch {
-      NSLog("Error: \(error)")
-      return nil
+
+    guard let url = URL(string: "\(domainURL)/api/trpc/notification.sendSingleNotification") else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Invalid URL")
+      return
     }
-  }
-  
-  func copyFile(at srcURL: URL, to dstURL: URL) -> Bool {
-    do {
-      if FileManager.default.fileExists(atPath: dstURL.path) {
-        try FileManager.default.removeItem(at: dstURL)
+
+    let notificationData: [String: Any] = [
+      "expoPushToken": "",  // Leave this empty as we don't have a token
+      "title": "Login Required",
+      "body": "Please log in to save events to Soonlist",
+      "data": [String: String]()
+    ]
+
+    guard let jsonData = try? JSONSerialization.data(withJSONObject: notificationData) else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Failed to serialize notification data")
+      return
+    }
+
+    var request = URLRequest(url: url)
+    request.httpMethod = "POST"
+    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
+
+    let task = URLSession.shared.uploadTask(with: request, from: jsonData) { data, response, error in
+      if let error = error {
+        NSLog("soonlist.share-extension.shareviewcontroller: Error sending notification: \(error)")
+        return
+      }
+
+      if let httpResponse = response as? HTTPURLResponse {
+        NSLog("soonlist.share-extension.shareviewcontroller: Notification HTTP Status Code: \(httpResponse.statusCode)")
+      }
+
+      if let data = data, let responseString = String(data: data, encoding: .utf8) {
+        NSLog("soonlist.share-extension.shareviewcontroller: Notification Response: \(responseString)")
       }
-      try FileManager.default.copyItem(at: srcURL, to: dstURL)
-    } catch (let error) {
-      NSLog("Cannot copy item at \(srcURL) to \(dstURL): \(error)")
-      return false
     }
-    return true
+
+    task.resume()
   }
-  
-  private func getSharedMediaFile(forVideo: URL, fileName: String, fileSize: Int?, mimeType: String) -> SharedMediaFile? {
-    let asset = AVAsset(url: forVideo)
-    let duration = (CMTimeGetSeconds(asset.duration) * 1000).rounded()
-    let thumbnailPath = getThumbnailPath(for: forVideo)
-    
-    
-    if FileManager.default.fileExists(atPath: thumbnailPath.path) {
-      return SharedMediaFile(path: forVideo.absoluteString, thumbnail: thumbnailPath.absoluteString, fileName: fileName, fileSize: fileSize, width: nil, height: nil, duration: duration, mimeType: mimeType, type: .video)
+
+  // Add this new method
+  private func sendFailureNotification(authData: AuthData) {
+    NSLog("soonlist.share-extension.shareviewcontroller: Sending failure notification")
+    guard let domainURL = KeychainHelper.getValue(forKey: "EXPO_PUBLIC_API_BASE_URL") else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Failed to load EXPO_PUBLIC_API_BASE_URL from Keychain")
+      return
     }
-    
-    var saved = false
-    let assetImgGenerate = AVAssetImageGenerator(asset: asset)
-    assetImgGenerate.appliesPreferredTrackTransform = true
-    assetImgGenerate.maximumSize =  CGSize(width: 360, height: 360)
-    do {
-      let img = try assetImgGenerate.copyCGImage(at: CMTimeMakeWithSeconds(600, preferredTimescale: Int32(1.0)), actualTime: nil)
-      try UIImage.pngData(UIImage(cgImage: img))()?.write(to: thumbnailPath)
-      saved = true
-    } catch {
-      saved = false
+
+    guard let url = URL(string: "\(domainURL)/api/trpc/notification.sendSingleNotification") else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Invalid URL")
+      return
     }
-    
-    return saved ? SharedMediaFile(path: forVideo.absoluteString, thumbnail: thumbnailPath.absoluteString, fileName: fileName, fileSize: fileSize, width: nil, height: nil, duration: duration, mimeType: mimeType, type: .video) : nil
+
+    let notificationData: [String: Any] = [
+      "expoPushToken": authData.expoPushToken,
+      "title": "Event Creation Failed",
+      "body": "We couldn't create your event. Please try again later.",
+      "data": [String: String]()
+    ]
+
+    guard let jsonData = try? JSONSerialization.data(withJSONObject: notificationData) else {
+      NSLog("soonlist.share-extension.shareviewcontroller: Failed to serialize notification data")
+      return
+    }
+
+    var request = URLRequest(url: url)
+    request.httpMethod = "POST"
+    request.setValue("application/json", forHTTPHeaderField: "Content-Type")
+
+    let task = URLSession.shared.uploadTask(with: request, from: jsonData) { data, response, error in
+      if let error = error {
+        NSLog("soonlist.share-extension.shareviewcontroller: Error sending notification: \(error)")
+        return
+      }
+
+      if let httpResponse = response as? HTTPURLResponse {
+        NSLog("soonlist.share-extension.shareviewcontroller: Notification HTTP Status Code: \(httpResponse.statusCode)")
+      }
+
+      if let data = data, let responseString = String(data: data, encoding: .utf8) {
+        NSLog("soonlist.share-extension.shareviewcontroller: Notification Response: \(responseString)")
+      }
+    }
+
+    task.resume()
   }
-  
-  private func getThumbnailPath(for url: URL) -> URL {
-    let fileName = Data(url.lastPathComponent.utf8).base64EncodedString().replacingOccurrences(of: "==", with: "")
-    let path = FileManager.default
-      .containerURL(forSecurityApplicationGroupIdentifier: "group.\(hostAppBundleIdentifier)")!
-      .appendingPathComponent("\(fileName).jpg")
-    return path
+}
+
+struct PrototypeEventCreateRawTextSchema: Codable {
+  let json: EventData
+
+  struct EventData: Codable {
+    let rawText: String
+    let timezone: String
+    let expoPushToken: String
+    let lists: [String]
+    let userId: String
+    let username: String
   }
-  
-  class SharedMediaFile: Codable {
-    var path: String; // can be image, video or url path
-    var thumbnail: String?; // video thumbnail
-    var fileName: String; // uuid + extension
-    var fileSize: Int?;
-    var width: Int?; // for image
-    var height: Int?; // for image
-    var duration: Double?; // video duration in milliseconds
-    var mimeType: String;
-    var type: SharedMediaType;
-    
-    init(path: String, thumbnail: String?, fileName: String, fileSize: Int?, width: Int?, height: Int?, duration: Double?, mimeType: String, type: SharedMediaType) {
-      self.path = path
-      self.thumbnail = thumbnail
-      self.fileName = fileName
-      self.fileSize = fileSize
-      self.width = width
-      self.height = height
-      self.duration = duration
-      self.mimeType = mimeType
-      self.type = type
+}
+
+struct PrototypeEventCreateImageSchema: Codable {
+  let json: EventData
+
+  struct EventData: Codable {
+    let imageUrl: String
+    let timezone: String
+    let expoPushToken: String
+    let lists: [String]
+    let userId: String
+    let username: String
+  }
+}
+
+class KeychainHelper {
+  static func getValue(forKey key: String) -> String? {
+    let query: [String: Any] = [
+      kSecClass as String: kSecClassGenericPassword,
+      kSecAttrService as String: "app:no-auth",
+      kSecAttrAccount as String: key,
+      kSecReturnData as String: true,
+      kSecAttrAccessGroup as String: "group.soonlist.soonlist",
+    ]
+
+    var item: CFTypeRef?
+    let status = SecItemCopyMatching(query as CFDictionary, &item)
+
+    guard status == errSecSuccess,
+      let data = item as? Data,
+      let value = String(data: data, encoding: .utf8)
+    else {
+      return nil
     }
+
+    return value
+  }
+}
+
+func loadAuthData() -> AuthData? {
+  NSLog("soonlist.share-extension.shareviewcontroller: Attempting to load auth data from Keychain")
+
+  logAllKeys()
+
+  let query: [String: Any] = [
+    kSecClass as String: kSecClassGenericPassword,
+    kSecAttrAccessGroup as String: "group.soonlist.soonlist",
+    kSecReturnData as String: false,
+  ]
+
+  let status = SecItemCopyMatching(query as CFDictionary, nil)
+
+  switch status {
+  case errSecSuccess:
+    NSLog("soonlist.share-extension.shareviewcontroller: Keychain is accessible")
+  case errSecItemNotFound:
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Keychain item not found. This may be normal if no data has been saved yet."
+    )
+  case errSecInteractionNotAllowed:
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Keychain access not allowed. This might be due to device lock state."
+    )
+  case errSecAuthFailed:
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Keychain authentication failed. Check entitlements and provisioning profile."
+    )
+  default:
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Keychain is not accessible. Error: \(status)")
   }
-  
-  enum SharedMediaType: Int, Codable {
-    case image
-    case video
-    case file
+
+  guard status == errSecSuccess else {
+    return nil
   }
-  
-  func toData(data: [SharedMediaFile]) -> Data {
-    let encodedData = try? JSONEncoder().encode(data)
-    return encodedData!
+
+  guard let authDataString = KeychainHelper.getValue(forKey: "authData") else {
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Failed to retrieve authData string from Keychain"
+    )
+    return nil
   }
-}
 
-internal let mimeTypes = [
-    "html": "text/html",
-    "htm": "text/html",
-    "shtml": "text/html",
-    "css": "text/css",
-    "xml": "text/xml",
-    "gif": "image/gif",
-    "jpeg": "image/jpeg",
-    "jpg": "image/jpeg",
-    "js": "application/javascript",
-    "atom": "application/atom+xml",
-    "rss": "application/rss+xml",
-    "mml": "text/mathml",
-    "txt": "text/plain",
-    "jad": "text/vnd.sun.j2me.app-descriptor",
-    "wml": "text/vnd.wap.wml",
-    "htc": "text/x-component",
-    "png": "image/png",
-    "tif": "image/tiff",
-    "tiff": "image/tiff",
-    "wbmp": "image/vnd.wap.wbmp",
-    "ico": "image/x-icon",
-    "jng": "image/x-jng",
-    "bmp": "image/x-ms-bmp",
-    "svg": "image/svg+xml",
-    "svgz": "image/svg+xml",
-    "webp": "image/webp",
-    "woff": "application/font-woff",
-    "jar": "application/java-archive",
-    "war": "application/java-archive",
-    "ear": "application/java-archive",
-    "json": "application/json",
-    "hqx": "application/mac-binhex40",
-    "doc": "application/msword",
-    "pdf": "application/pdf",
-    "ps": "application/postscript",
-    "eps": "application/postscript",
-    "ai": "application/postscript",
-    "rtf": "application/rtf",
-    "m3u8": "application/vnd.apple.mpegurl",
-    "xls": "application/vnd.ms-excel",
-    "eot": "application/vnd.ms-fontobject",
-    "ppt": "application/vnd.ms-powerpoint",
-    "wmlc": "application/vnd.wap.wmlc",
-    "kml": "application/vnd.google-earth.kml+xml",
-    "kmz": "application/vnd.google-earth.kmz",
-    "7z": "application/x-7z-compressed",
-    "cco": "application/x-cocoa",
-    "jardiff": "application/x-java-archive-diff",
-    "jnlp": "application/x-java-jnlp-file",
-    "run": "application/x-makeself",
-    "pl": "application/x-perl",
-    "pm": "application/x-perl",
-    "prc": "application/x-pilot",
-    "pdb": "application/x-pilot",
-    "rar": "application/x-rar-compressed",
-    "rpm": "application/x-redhat-package-manager",
-    "sea": "application/x-sea",
-    "swf": "application/x-shockwave-flash",
-    "sit": "application/x-stuffit",
-    "tcl": "application/x-tcl",
-    "tk": "application/x-tcl",
-    "der": "application/x-x509-ca-cert",
-    "pem": "application/x-x509-ca-cert",
-    "crt": "application/x-x509-ca-cert",
-    "xpi": "application/x-xpinstall",
-    "xhtml": "application/xhtml+xml",
-    "xspf": "application/xspf+xml",
-    "zip": "application/zip",
-    "epub": "application/epub+zip",
-    "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
-    "xlsx": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
-    "pptx": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
-    "mid": "audio/midi",
-    "midi": "audio/midi",
-    "kar": "audio/midi",
-    "mp3": "audio/mpeg",
-    "ogg": "audio/ogg",
-    "m4a": "audio/x-m4a",
-    "ra": "audio/x-realaudio",
-    "3gpp": "video/3gpp",
-    "3gp": "video/3gpp",
-    "ts": "video/mp2t",
-    "mp4": "video/mp4",
-    "mpeg": "video/mpeg",
-    "mpg": "video/mpeg",
-    "mov": "video/quicktime",
-    "webm": "video/webm",
-    "flv": "video/x-flv",
-    "m4v": "video/x-m4v",
-    "mng": "video/x-mng",
-    "asx": "video/x-ms-asf",
-    "asf": "video/x-ms-asf",
-    "wmv": "video/x-ms-wmv",
-    "avi": "video/x-msvideo"
-]
-
-extension URL {
-  func mimeType(ext: String?) -> String {
-    if #available(iOSApplicationExtension 14.0, *) {
-      if let pathExt = ext,
-        let mimeType = UTType(filenameExtension: pathExt)?.preferredMIMEType {
-        return mimeType
-      } else {
-        return "application/octet-stream"
+  NSLog(
+    "soonlist.share-extension.shareviewcontroller: Retrieved authData string: \(authDataString)")
+
+  guard let authDataData = authDataString.data(using: .utf8) else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Failed to convert authData string to Data")
+    return nil
+  }
+
+  do {
+    if let authData = try JSONSerialization.jsonObject(with: authDataData, options: [])
+      as? [String: String]
+    {
+      NSLog("soonlist.share-extension.shareviewcontroller: Successfully parsed authData JSON")
+
+      guard let userId = authData["userId"],
+        let username = authData["username"],
+        let authToken = authData["authToken"],
+        let expoPushToken = authData["expoPushToken"]
+      else {
+        NSLog(
+          "soonlist.share-extension.shareviewcontroller: One or more required fields not found in authData"
+        )
+        return nil
       }
+
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: Successfully retrieved all required fields from authData"
+      )
+      return AuthData(
+        userId: userId, username: username, authToken: authToken, expoPushToken: expoPushToken)
     } else {
-      return mimeTypes[ext?.lowercased() ?? "" ] ?? "application/octet-stream"
+      NSLog(
+        "soonlist.share-extension.shareviewcontroller: Failed to cast parsed JSON to [String: String]"
+      )
     }
+  } catch {
+    NSLog("soonlist.share-extension.shareviewcontroller: Error parsing authData JSON: \(error)")
   }
+
+  NSLog("soonlist.share-extension.shareviewcontroller: Failed to load auth data")
+  return nil
 }
 
-extension Array {
-  subscript (safe index: UInt) -> Element? {
-    return Int(index) < count ? self[Int(index)] : nil
+func logAllKeys() {
+  NSLog("soonlist.share-extension.shareviewcontroller: Attempting to log all keychain items")
+
+  let query: [String: Any] = [
+    kSecClass as String: kSecClassGenericPassword,
+    kSecReturnData as String: true,
+    kSecReturnAttributes as String: true,
+    kSecMatchLimit as String: kSecMatchLimitAll,
+  ]
+
+  var item: CFTypeRef?
+  let status = SecItemCopyMatching(query as CFDictionary, &item)
+
+  guard status != errSecItemNotFound else {
+    NSLog("soonlist.share-extension.shareviewcontroller: No keychain items found")
+    return
+  }
+
+  guard status == errSecSuccess else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Error fetching keychain items: \(status)")
+    return
+  }
+
+  guard let existingItems = item as? [[String: Any]] else {
+    NSLog("soonlist.share-extension.shareviewcontroller: Unexpected result type")
+    return
+  }
+
+  for (index, existingItem) in existingItems.enumerated() {
+    let account = existingItem[kSecAttrAccount as String] as? String ?? "Unknown Account"
+    let passwordData = existingItem[kSecValueData as String] as? Data
+    let password =
+      passwordData != nil
+      ? String(data: passwordData!, encoding: .utf8) ?? "Unable to decode" : "No password data"
+
+    NSLog(
+      "soonlist.share-extension.shareviewcontroller: Item \(index + 1): Account: \(account), Password: \(password)"
+    )
+
+    // Log all attributes for debugging
+    for (key, value) in existingItem {
+      NSLog("soonlist.share-extension.shareviewcontroller: Item \(index + 1) - \(key): \(value)")
+    }
   }
 }
diff --git a/plugin/build/ios/withIosShareExtensionXcodeTarget.js b/plugin/build/ios/withIosShareExtensionXcodeTarget.js
index 9d192ccaebf4bae7195d1e735f5aef67a8283461..0593f3f5253da74272c711a7796ad7bb895e2658 100644
--- a/plugin/build/ios/withIosShareExtensionXcodeTarget.js
+++ b/plugin/build/ios/withIosShareExtensionXcodeTarget.js
@@ -61,6 +61,7 @@ const withShareExtensionXcodeTarget = (config, parameters) => {
                     buildSettingsObj["SWIFT_EMIT_LOC_STRINGS"] = "YES";
                     buildSettingsObj["SWIFT_VERSION"] = "5.0";
                     buildSettingsObj["TARGETED_DEVICE_FAMILY"] = `"1,2"`;
+                    buildSettingsObj["IPHONEOS_DEPLOYMENT_TARGET"] = "15.0";
                 }
             }
         }
